
### 1주차 - ERD, API 설계
<<<<<<< HEAD


---

### API

: 애플리케이션 프로그래밍 인터페이스

다른 소프트웨어 시스템과 통신하기 위해 따라야 하는 규칙을 정의함

웹 API는 클라이언트와 웹 리소스 사이의 게이트웨이라고 생각할 수 있음

→ 즉 서버가 클라이언트에게 나눠준 메뉴판이라고 이해하면 댐

(메뉴판의 메뉴를 고르면 서버가 그 메뉴에대한 응답을 함)

### REST

: API 작동 방식에 대한 조건을 부과하는 소프트웨어 아키텍쳐

- 균일한 인터페이스 (즉 요청을 보내는 주소만으로도 대략 어떤 요청인지 파악가능함)
    
    모든 RESTful 웹 서비스 디자인의 기본. 이는 서버가 표준 형식으로 정보를 전송함을 나타냄
    
    4가지 아키텍쳐 제약조건
    
    - 요청은 리소스를 식별해야함, 이를 위해 균일한 리소스 식별자를 사용함
    - 클라이언트는 원하는 경우 리소스를 수정하거나 삭제하기에 충분한 정보를 리소스 표현에서 가지고 있음. 서버는 리소스를 자세히 설명하는 메타데이터를 전송하여 이 조건을 충족함
    - 클라이언트는 표현을추가로 처리하는 방법에 대한 정보를 수신함. 이를 위해 서버는 클라이언트가 리소스를 적절하게 사용할 수 있는 방법에 대한 메타데이터가 포함된 명확한 메시지를 전송함
    - 클라이언트는 작업을 완료하는데 필요한 다른 모든 관련 리소스에 대한 정보를 수신함. 이를 위해 서버는 클라이언트가 더 많은 리소스를 동적으로 검색할 수 있도록 표현에 하이퍼 링크를 넣어 전송함
- 무상태
    
    서버가 이전의 모든 요청과 독립적으로 모든 클라이언트 요청을 완료하는 통신 방법. 클라이언트는 임의의 순서로 리소스를 요청할 수 있으며 모든 요청은 무상태 이거나 다른 요청과 분리됨. → 서버가 매번 요청을 완전히 이해해서 이행할 수 있음을 의미
    
- 계층화 시스템
    
    클라이언트는 클라이언트와 서버 사이의 다른 승인된 중개자에게 연결할 수 있으며 여전히 서버로부터도 응답을 받음. 서버는 요청을 다른 서버로 전달할 수도있음. 클라이언트의요청을 이행하기 위해 여러 계층으로 여러 서버에서 실행되도록 RESTful 웹 서비스를 설계 할 수 있음.  
    
- 캐시 가능성
    
    서버 응답 시간을 개선하기 위해 클라이언트 또는 중개자에게 일부 응답을 저장하는 프로세스인 캐싱을 지원함. RESTful 웹 서비스는 캐시 가능/불가능으로 정의되는 API응답을 사용하여 캐싱을 제어함
    
- 온디맨드 코드
    
    소프트웨어 프로그래밍 코드를 클라이언트에 전송하여 클라이언트 기능을 일시적으로 확장하거나 사용자 지정할 수 있음.
    

### Restful API (REST 아키텍쳐 스타일을 따르는 API)

: 두 컴퓨터 시스템이 **인터넷을 통해** 정보를 안전하게 교환하기 위해 사용하는 **인터페이스**

RESTful API의 이점

1. 확장성
2. 유연성
3. 독립성

메서드

- GET : 조회
- PUT : 전제 수정
- POST : 생성
- DELETE : 삭제
- PATCH : 부분 수정

![스크린샷 2024-07-23 173041](https://github.com/user-attachments/assets/f4eeb82b-fca7-4f43-8c75-e0fca6788010)

→ post, put, patch는 get, delete보다 용량이 큼, 즉 더 많은 정보를 보낼 수 있음

### ERD


![스크린샷 2024-07-26 114339](https://github.com/user-attachments/assets/b8d3cd07-2f9b-4018-9e1c-a6a858ea6f40)


### API
[제목 없는 데이터베이스](https://www.notion.so/dc193a226de74e1a9b072922f378b6df?pvs=21)


=======
| 여기에 작성해주세요

### 2주차 - 상품 관련 DTO 및 ENTITY 구현


**ERD 재설계**
![image](https://github.com/user-attachments/assets/edab4b0e-b0e0-428f-b087-73115e5e8fc0)


-> 확실히 엔티티와 DTO를 작성하면서 조금 보완이 되는 느낌이다. 계산된 필드는 제거했고 옵션은 등록을 위해서 남겨두었다

**반정규화**

- 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
- 저의 경우는 상품테이블에 할인율이라는 속성을 계산된 필드로 사용했습니다

-> 할인가가 자주 변동된다면 계산된 필드를 사용하는 것이 좋을 수도 있지만 그렇지 않다면 그저 가격만 저장해도 될 것 같아 제거함.

**API 재설계**

1. 각각의 요청에 대한 상태코드를 반환   
2. 실패하는 경우에 상황을 특정하자
3. 요청으로 필요한 값을 모두 전달하자   
4. 페이지 조회 기능... 추가해보자   


**API 수정**

[https://www.notion.so/pusan-dev/2-API-42133cdcdb894e11b8ec17ec32c0ebe4](https://www.notion.so/pusan-dev/2-API-42133cdcdb894e11b8ec17ec32c0ebe4)



**DTO(Data Transfer Object)**   
- 데이터 전송 객체(필요한 데이터만 전달하기 위해 사용)   
- 엔티티가 가지는 민감한 정보는 노출하지 않기 위해 사용   
- 각 DTO 에는 필요한 정보만을 등록,조회,삭제,수정할 수 있도록 설계   
- 비즈니스 로직은 들어가면 안된다(서비스에서 처리)      
  
**Entity**   
- 데이터 베이스에 직접 연결된 테이블
- 민감한 정보를 가지고 있어 사용에 주의(비밀번호, 주민등록번호)
- 엔티티는 데이터베이스 접근이 가능, 이것을 직접 조회하면 보안에 취약


-> 엔티티 대신 DTO를 사용하는 이유는 엔티티가 가지는 민감한 정보를 노출하지 않음과 동시에 필요한 정보만을 전달하기 위함이다   
    (엔티티의 크기가 클 경우 트래픽을 줄이는 용도로도 사용한다)   

 **record**    
- record는 get, toString, tohashcode, equals등의 메소드를 지원하고 모든 필드를 초기화하는 생성자를    자동으로 생성해 준다
- record가 가지는 필드는 불변으로 생성자를 통해 값을 저장하고 나면 바뀌지 않는다
- 실제 클래스를 작성하는 것보다 간단하고 편리하다(직접 작성해 보니 그렇다)



**Entity 설계 과정**

- 엔티티가 가질 속성을 정의   
- 데이터의 무결성 조건을 정의 (ex nullable = false, uniqueConstraints = @UniqueConstraint(name = " uk_variable_name", ColumnNames = "variable_name")
- 기본키 생성(IDENTITY 전략 선택)
- 각 엔티티의 관계에 따라 @ManyToOne, @OneToMany 등의 관계를 정의, 각 엔티티에서 양방향으로 정의
- 객체 생성 패턴으로 @Builder 선택(체이닝 형식으로 객체를 생성하여 가독성이 높고 편리하다)

**DTO 설계 과정**

처음에는 각각의 기능에 따른 클래스를 선언하여 필요한 것들을 필드로 가지고, 생성자를 통해서만 값을 지정하는 방식으로 설계했다    
-> 추후에 레코드를 사용하여 코드를 수정했다.  

- 엔티티 객체를 매개변수로 받아 getter를 통해 생성자에 값을 저장
- 한번씩 로그인과 같이 필요한 매개변수가 정해져 있는 경우에는 이메일, 비밀번호만 매개변수로 한 생성자를 만듬  
- 각각의 엔티티 간의 관계에 유념해서 외래키로 값을 가지고 오는 경로를 확인
- 클래스의 필드는 불변 객체로, 값을 변경하는 것은 생성자를 통해서만   

**과제 진행하면서 잘 모르겠는 것** 

사용자 Dto를 예시로 들겠습니다.
```

public record loginUser(String email, String password){
            public loginUser(User user){
                this(user.getEmail(),user.getPassword());
            }

// 위 레코드에서는 엔티티 객체를 생성자의 매개변수로 받아 get 메소드를 통해서 값을 저장하고 있고 

@Getter
        public static class userLogin{

            public final String email;
            public final String password;

            public userLogin(String email, String password){
                this.email = email;
                this.password = password;
            }

        }

/*
하단의 정적 클래스는 로그인에 필요한 값만 생성자의 매개변수로 받아서 값을 저장한다
이때 엔티티를 통해서 위와 같이 값을 가져오는 것이 맞는지 사용자의 입장에서 아래 코드와 같이 작성하는 것이
맞는지 둘중 어느 방식이 사용되어야 하는지 잘 모르겠다.... 그래서 일단은 전반적으로 DTO에 두가지 양식을 모두 작성했다.
*/

```
  



